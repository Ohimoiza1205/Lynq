// Replace your entire src/controllers/import.controller.ts with this
import { Request, Response } from 'express';
import { Video } from '../models/Video';
import { Segment } from '../models/Segment';
import { YouTubeService } from '../services/youtube.service';
import { TwelveLabsService } from '../services/twelvelabs.service';
import { logger } from '../utils/logger';

export class ImportController {
  private youtubeService: YouTubeService;
  private twelveLabsService: TwelveLabsService;

  constructor() {
    this.youtubeService = new YouTubeService();
    this.twelveLabsService = new TwelveLabsService();
  }

  async createImportJob(req: Request, res: Response) {
    try {
      const { queries, maxResults = 5, tags = [] } = req.body;
      const userId = (req as any).user?.sub || 'anonymous';

      logger.info('YouTube import started', { queries, maxResults, userId });

      if (!queries || !Array.isArray(queries) || queries.length === 0) {
        return res.status(400).json({ error: 'Queries array is required' });
      }

      // Search YouTube immediately
      const allVideos = [];
      for (const query of queries) {
        try {
          const searchResults = await this.youtubeService.searchVideos(query, maxResults);
          if (searchResults.items) {
            allVideos.push(...searchResults.items);
          }
        } catch (error) {
          logger.error('YouTube search failed', { query, error });
        }
      }

      if (allVideos.length === 0) {
        return res.status(404).json({ error: 'No videos found' });
      }

      // Import videos immediately
      const importedVideos = [];
      for (const youtubeVideo of allVideos.slice(0, maxResults)) {
        try {
          const video = await this.importVideo(youtubeVideo, userId, tags);
          importedVideos.push(video);
          
          // Start processing
          this.processVideo(video._id.toString(), youtubeVideo.id.videoId);
        } catch (error) {
          logger.error('Video import failed', { videoId: youtubeVideo.id.videoId, error });
        }
      }

      res.json({
        success: true,
        message: `Imported ${importedVideos.length} videos`,
        videos: importedVideos.map(v => ({
          id: v._id,
          title: v.title,
          status: v.status
        }))
      });

    } catch (error) {
      logger.error('Import job failed', error);
      res.status(500).json({ error: 'Import failed' });
    }
  }

  async getJobStatus(req: Request, res: Response) {
    try {
      const { jobId } = req.params;
      const video = await Video.findById(jobId);
      
      if (!video) {
        return res.status(404).json({ error: 'Job not found' });
      }

      res.json({
        jobId,
        status: video.status,
        title: video.title,
        progress: this.getProgress(video.status)
      });
    } catch (error) {
      logger.error('Job status error', error);
      res.status(500).json({ error: 'Failed to get status' });
    }
  }

  private async importVideo(youtubeVideo: any, userId: string, tags: string[]) {
    const videoDetails = await this.youtubeService.getVideoDetails([youtubeVideo.id.videoId]);
    const videoInfo = videoDetails.items[0];

    if (!videoInfo) {
      throw new Error('Video details not found');
    }

    const title = videoInfo.snippet.title;
    const description = videoInfo.snippet.description || '';
    const duration = this.parseDuration(videoInfo.contentDetails.duration);
    const youtubeUrl = `https://www.youtube.com/watch?v=${youtubeVideo.id.videoId}`;
    const thumbnailUrl = videoInfo.snippet.thumbnails.high?.url || 
                        videoInfo.snippet.thumbnails.medium?.url ||
                        videoInfo.snippet.thumbnails.default?.url;

    const video = new Video({
      ownerId: userId,
      source: 'youtube',
      videoId: youtubeVideo.id.videoId,
      title: title.trim(),
      description: description.trim(),
      track: 'healthcare',
      status: 'uploaded',
      durationSec: duration,
      tags: [...tags, 'youtube-import'],
      watchUrl: youtubeUrl,
      thumbnailUrl
    });

    await video.save();
    logger.info('Video imported', { videoId: video._id, title: title.substring(0, 50) });
    return video;
  }

  private async processVideo(videoId: string, youtubeId: string) {
    try {
      const video = await Video.findById(videoId);
      if (!video) return;

      video.status = 'indexing';
      await video.save();

      const youtubeUrl = `https://www.youtube.com/watch?v=${youtubeId}`;
      
      // Create mock segments for now since Twelve Labs might not be set up
      await this.createMockSegments(videoId);
      
      video.status = 'ready';
      await video.save();

      logger.info('Video processing completed', { videoId });

    } catch (error) {
      logger.error('Video processing failed', { videoId, error });
      await Video.findByIdAndUpdate(videoId, { status: 'failed' });
    }
  }

  private async createMockSegments(videoId: string) {
    const mockSegments = [
      { start: 0, end: 30, text: 'Introduction and patient preparation for the surgical procedure' },
      { start: 30, end: 120, text: 'Initial incision and tissue dissection using laparoscopic techniques' },
      { start: 120, end: 240, text: 'Identification of anatomical landmarks and target structures' },
      { start: 240, end: 360, text: 'Primary surgical intervention and tissue manipulation' },
      { start: 360, end: 450, text: 'Hemostasis and wound closure procedures' }
    ];

    for (const seg of mockSegments) {
      const segment = new Segment({
        videoId,
        startSec: seg.start,
        endSec: seg.end,
        captions: [seg.text],
        vector: [],
        labels: ['surgical-procedure'],
        confidence: 0.85
      });
      await segment.save();
    }
  }

  private getProgress(status: string): number {
    switch (status) {
      case 'uploaded': return 20;
      case 'indexing': return 60;
      case 'ready': return 100;
      case 'failed': return 0;
      default: return 0;
    }
  }

  private parseDuration(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;
    
    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');
    
    return hours * 3600 + minutes * 60 + seconds;
  }
}