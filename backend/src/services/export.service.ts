import { Video } from '../models/Video';
import { Segment } from '../models/Segment';
import { Event } from '../models/Event';
import { Quiz } from '../models/Quiz';
import { logger } from '../utils/logger';

interface ExportData {
  video: any;
  segments: any[];
  events: any[];
  quiz?: any;
  highlights?: string[];
  notes?: string[];
}

export class ExportService {
  async generatePDFData(videoId: string, options: any = {}): Promise<ExportData> {
    try {
      const video = await Video.findById(videoId);
      if (!video) {
        throw new Error('Video not found');
      }

      const segments = await Segment.find({ videoId }).sort({ startSec: 1 });
      const events = await Event.find({ videoId }).sort({ startSec: 1 });
      const quiz = await Quiz.findOne({ videoId });

      const exportData: ExportData = {
        video: {
          id: video._id,
          title: video.title,
          description: video.description,
          duration: video.durationSec,
          tags: video.tags,
          source: video.source,
          createdAt: video.createdAt
        },
        segments: segments.map(s => ({
          startTime: this.formatTimestamp(s.startSec),
          endTime: this.formatTimestamp(s.endSec),
          duration: s.endSec - s.startSec,
          content: s.captions.join(' '),
          confidence: s.confidence,
          labels: s.labels
        })),
        events: events.map(e => ({
          timestamp: this.formatTimestamp(e.startSec),
          type: e.type,
          description: e.notes,
          score: e.score,
          duration: e.endSec - e.startSec
        }))
      };

      if (quiz) {
        exportData.quiz = {
          questionCount: quiz.items.length,
          generatedAt: quiz.generatedAt,
          questions: quiz.items.map(item => ({
            question: item.question,
            type: item.type,
            timestamp: this.formatTimestamp(item.timestamp),
            options: item.options,
            correctAnswer: item.correctAnswer,
            explanation: item.explanation
          }))
        };
      }

      if (options.highlights) {
        exportData.highlights = options.highlights;
      }

      if (options.notes) {
        exportData.notes = options.notes;
      }

      logger.info('Export data generated', { videoId, segmentCount: segments.length });
      return exportData;
    } catch (error) {
      logger.error('Export data generation error', { videoId, error });
      throw error;
    }
  }

  generatePDFContent(data: ExportData): string {
    const { video, segments, events, quiz, highlights, notes } = data;
    
    let content = `# Training Report: ${video.title}\n\n`;
    
    content += `## Video Information\n`;
    content += `- **Title**: ${video.title}\n`;
    content += `- **Description**: ${video.description || 'No description'}\n`;
    content += `- **Duration**: ${this.formatTimestamp(video.duration)}\n`;
    content += `- **Source**: ${video.source}\n`;
    content += `- **Tags**: ${video.tags.join(', ')}\n`;
    content += `- **Generated**: ${new Date().toLocaleDateString()}\n\n`;

    if (segments.length > 0) {
      content += `## Video Transcript\n\n`;
      segments.forEach((segment, index) => {
        content += `**[${segment.startTime} - ${segment.endTime}]**\n`;
        content += `${segment.content}\n\n`;
      });
    }

    if (events.length > 0) {
      content += `## Key Events\n\n`;
      events.forEach(event => {
        content += `- **${event.timestamp}** - ${event.type.toUpperCase()}: ${event.description}\n`;
      });
      content += '\n';
    }

    if (quiz) {
      content += `## Quiz Questions (${quiz.questionCount} total)\n\n`;
      quiz.questions.forEach((q: any, index: number) => {
        content += `**Question ${index + 1}** [${q.timestamp}]\n`;
        content += `${q.question}\n\n`;
        if (q.type === 'mcq' && q.options) {
          q.options.forEach((option: string, i: number) => {
            const marker = option === q.correctAnswer ? 'âœ“' : ' ';
            content += `${String.fromCharCode(65 + i)}. [${marker}] ${option}\n`;
          });
        } else {
          content += `**Answer**: ${q.correctAnswer}\n`;
        }
        if (q.explanation) {
          content += `**Explanation**: ${q.explanation}\n`;
        }
        content += '\n';
      });
    }

    if (highlights && highlights.length > 0) {
      content += `## Highlights\n\n`;
      highlights.forEach(highlight => {
        content += `- ${highlight}\n`;
      });
      content += '\n';
    }

    if (notes && notes.length > 0) {
      content += `## Notes\n\n`;
      notes.forEach(note => {
        content += `- ${note}\n`;
      });
      content += '\n';
    }

    content += `---\n`;
    content += `*Report generated by Lynq VideoDoc AI on ${new Date().toISOString()}*`;

    return content;
  }

  generateCSVData(data: ExportData): string {
    const { segments, events, quiz } = data;
    
    let csv = 'Type,Timestamp,Duration,Content,Confidence,Labels\n';
    
    segments.forEach(segment => {
      const labels = segment.labels.join(';');
      const content = segment.content.replace(/"/g, '""');
      csv += `Transcript,"${segment.startTime}",${segment.duration},"${content}",${segment.confidence},"${labels}"\n`;
    });

    events.forEach(event => {
      const description = event.description.replace(/"/g, '""');
      csv += `Event,"${event.timestamp}",${event.duration},"${description}",${event.score},"${event.type}"\n`;
    });

    if (quiz) {
      quiz.questions.forEach((q: any) => {
        const question = q.question.replace(/"/g, '""');
        const answer = q.correctAnswer.replace(/"/g, '""');
        csv += `Quiz,"${q.timestamp}",0,"${question} | Answer: ${answer}",1.0,"${q.type}"\n`;
      });
    }

    return csv;
  }

  private formatTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
}